---
import { supabase } from "../../../lib/supabase";
import CardActions from "../../../components/CardActions";

const accessToken = Astro.cookies.get("sb-access-token");
const refreshToken = Astro.cookies.get("sb-refresh-token");

if (!accessToken || !refreshToken) {
  return Astro.redirect("/signin");
}

let session;
try {
  session = await supabase.auth.setSession({
    refresh_token: refreshToken.value,
    access_token: accessToken.value,
  });
  if (session.error) {
    Astro.cookies.delete("sb-access-token", {
      path: "/",
    });
    Astro.cookies.delete("sb-refresh-token", {
      path: "/",
    });
    return Astro.redirect("/signin");
  }
} catch (error) {
  Astro.cookies.delete("sb-access-token", {
    path: "/",
  });
  Astro.cookies.delete("sb-refresh-token", {
    path: "/",
  });
  return Astro.redirect("/signin");
}

export async function getStaticPaths() {
  const { data: sets, error } = await supabase
    .from('sets')
    .select('code')
    .eq('game_id', 'bd6b0e9f-e292-4ac0-b0e6-d8b9886f4d3d');

  if (error) {
    console.error('Error fetching Digimon sets for static paths:', error);
    return [];
  }

  return sets.map((set) => ({
    params: { setCode: set.code },
  }));
}

const { setCode } = Astro.params;

let set;
let baseCardsWithVersions;
let userId: string | null = null;

if (setCode) {
  const { data: { session } } = await supabase.auth.getSession();
  userId = session?.user?.id || null;
  
  const { data: selectedSet, error: setError } = await supabase
    .from('sets')
    .select('*')
    .eq('code', setCode)
    .single();

  if (setError) {
    console.error('Error fetching set:', setError);
  } else {
    set = selectedSet;

    // Fetch all base cards for the selected set
    const { data: baseCards, error: baseCardsError } = await supabase
      .from('base_cards')
      .select('*')
      .eq('set', set.code);

    if (baseCardsError) {
      console.error('Error fetching base cards:', baseCardsError);
    } else {
      // Fetch all cards for the selected set
      const { data: allCards, error: allCardsError } = await supabase
        .from('cards')
        .select('base_cards(number, name, type), version, rarity, img_url')
        .in(
          'base_number',
          baseCards.map((bc) => bc.number)
        );

      if (allCardsError) {
        console.error('Error fetching all cards:', allCardsError);
      } else {
        // Group cards by base card number
        const groupedCards = baseCards.map((baseCard) => {
          return {
            baseCard,
            versions: allCards.filter(
              (card) => card.base_cards?.number === baseCard.number
            ),
          };
        });
        baseCardsWithVersions = groupedCards;
      }
    }
  }
}

let userCardQuantities: Record<string, number> = {};
if (userId) {
  const { data, error } = await supabase
    .from('user_cards')
    .select('card_id, quantity')
    .eq('user_id', userId);
  if (data) {
    data.forEach(item => userCardQuantities[item.card_id] = item.quantity);
  }
}
---


<main title={set ? `Digimon TCG - ${set.code}` : 'Digimon TCG - Set Details'}>
  {set ? (
    <>
      <h1>{set.name}</h1>
      <p>Here are the cards in the {set.code} set:</p>

      {baseCardsWithVersions && baseCardsWithVersions.length > 0 ? (
        <div class="card-list">
          {baseCardsWithVersions.map(({ baseCard, versions }) => (
            <div class="base-card-container">
              <div class="base-card-info">
                <h3>{baseCard.name}</h3>
                <h3>{baseCard.number}</h3>
                <p>Type: {baseCard.type}</p>
              </div>
              <div class="card-versions">
                {versions.map((card) => {
  console.log("Card object in [setCode].astro:", card);
  return (
    <div class="card-version">
      <img src={card.img_url} alt={card.base_cards?.name}/>
      <p class="rarity">{card.rarity}</p>
      {userId && (
        <CardActions
          client:visible
          cardId={card.id}
          userId={userId}
        />
      )}
      {!userId && <p>Log in to track</p>}
    </div>
  );
})}
              </div>
            </div>
          ))}
        </div>
      ) : (
        <p>No cards found in this set.</p>
      )}
    </>
  ) : (
    <p>Set not found.</p>
  )}
</main>

<style>
  .card-list {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .base-card-container {
    border: 1px solid #ccc;
    padding: 15px;
    border-radius: 8px;
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }

  .base-card-info {
    flex-basis: 200px;
  }

  .card-versions {
    display: flex;
    gap: 10px;
    overflow-x: auto; /* Enable horizontal scrolling if needed */
  }

  .card-version {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }

  .card-version img {
    max-width: 150px;
    height: auto;
    border: 1px solid #eee;
    border-radius: 4px;
  }

  .rarity {
    margin-top: 5px;
    font-size: 0.9em;
    color: #777;
  }

  .collection-actions {
    display: flex;
    gap: 5px;
    align-items: center;
    margin-top: 5px;
  }
</style>